// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2012.2
// Copyright (C) 2012 Xilinx Inc. All rights reserved.
// 
// ==============================================================


`timescale 1ns/1ps

module master_if
#(parameter
    C_THREAD_ID_WIDTH = 1,
    C_ADDR_WIDTH      = 32,
    C_DATA_WIDTH      = 32,
    C_AWUSER_WIDTH    = 1,
    C_ARUSER_WIDTH    = 1,
    C_WUSER_WIDTH     = 1,
    C_RUSER_WIDTH     = 1,
    C_BUSER_WIDTH     = 1,
    C_USER_DATA_WIDTH = 8,
    C_TARGET_ADDR     = 32'h00000000,
    C_USER_VALUE      = 1'b0,
    C_PROT_VALUE      = 3'b010,
    C_CACHE_VALUE     = 4'b0000
)(
    // system signal
    input  wire                         ACLK,
    input  wire                         ARESETN,
    // write address channel
    output wire [C_THREAD_ID_WIDTH-1:0] AWID,
    output wire [C_ADDR_WIDTH-1:0]      AWADDR,
    output wire [7:0]                   AWLEN,
    output wire [2:0]                   AWSIZE,
    output wire [1:0]                   AWBURST,
    output wire [1:0]                   AWLOCK,
    output wire [3:0]                   AWCACHE,
    output wire [2:0]                   AWPROT,
    output wire [3:0]                   AWQOS,
    output wire [C_AWUSER_WIDTH-1:0]    AWUSER,
    output wire                         AWVALID,
    input  wire                         AWREADY,
    // write data channel
    output wire [C_DATA_WIDTH-1:0]      WDATA,
    output wire [C_DATA_WIDTH/8-1:0]    WSTRB,
    output wire                         WLAST,
    output wire [C_WUSER_WIDTH-1:0]     WUSER,
    output wire                         WVALID,
    input  wire                         WREADY,
    // write response channel
    input  wire [C_THREAD_ID_WIDTH-1:0] BID,
    input  wire [1:0]                   BRESP,
    input  wire [C_BUSER_WIDTH-1:0]     BUSER,
    input  wire                         BVALID,
    output wire                         BREADY,
    // read address channel
    output wire [C_THREAD_ID_WIDTH-1:0] ARID,
    output wire [C_ADDR_WIDTH-1:0]      ARADDR,
    output wire [7:0]                   ARLEN,
    output wire [2:0]                   ARSIZE,
    output wire [1:0]                   ARBURST,
    output wire [1:0]                   ARLOCK,
    output wire [3:0]                   ARCACHE,
    output wire [2:0]                   ARPROT,
    output wire [3:0]                   ARQOS,
    output wire [C_ARUSER_WIDTH-1:0]    ARUSER,
    output wire                         ARVALID,
    input  wire                         ARREADY,
    // read data channel
    input  wire [C_THREAD_ID_WIDTH-1:0] RID,
    input  wire [C_DATA_WIDTH-1:0]      RDATA,
    input  wire [1:0]                   RRESP,
    input  wire                         RLAST,
    input  wire [C_RUSER_WIDTH-1:0]     RUSER,
    input  wire                         RVALID,
    output wire                         RREADY,
    // user ports
    output wire [C_USER_DATA_WIDTH-1:0] USER_datain,
    input  wire [C_USER_DATA_WIDTH-1:0] USER_dataout,
    input  wire [31:0]                  USER_address,
    input  wire [31:0]                  USER_size,
    input  wire                         USER_req_din,
    output wire                         USER_req_full_n,
    input  wire                         USER_req_write,
    output wire                         USER_rsp_empty_n,
    input  wire                         USER_rsp_read
);
//------------------------Local signal-------------------
wire                         bus_ready;
wire                         bus_rdreq;
wire [C_ADDR_WIDTH-1:0]      bus_rdaddr;
wire [31:0]                  bus_rdlen;
wire                         bus_rdfull;
wire                         bus_rdpush;
wire [C_DATA_WIDTH-1:0]      bus_rddata;
wire                         bus_wrreq;
wire [C_ADDR_WIDTH-1:0]      bus_wraddr;
wire [31:0]                  bus_wrlen;
wire                         bus_wrempty;
wire                         bus_wrpop;
wire [C_DATA_WIDTH-1:0]      bus_wrdata;
//------------------------Instantiation------------------
// master_user_if
master_user_if #(
    .C_ADDR_WIDTH      ( C_ADDR_WIDTH ),
    .C_DATA_WIDTH      ( C_DATA_WIDTH ),
    .C_USER_DATA_WIDTH ( C_USER_DATA_WIDTH ),
    .C_TARGET_ADDR     ( C_TARGET_ADDR )
) ui (
    .ACLK              ( ACLK ),
    .ARESETN           ( ARESETN ),
    .USER_datain       ( USER_datain ),
    .USER_dataout      ( USER_dataout ),
    .USER_address      ( USER_address ),
    .USER_size         ( USER_size ),
    .USER_req_din      ( USER_req_din ),
    .USER_req_full_n   ( USER_req_full_n ),
    .USER_req_write    ( USER_req_write ),
    .USER_rsp_empty_n  ( USER_rsp_empty_n ),
    .USER_rsp_read     ( USER_rsp_read ),
    .bus_ready         ( bus_ready ),
    .bus_rdreq         ( bus_rdreq ),
    .bus_rdaddr        ( bus_rdaddr ),
    .bus_rdlen         ( bus_rdlen ),
    .bus_rdfull        ( bus_rdfull ),
    .bus_rdpush        ( bus_rdpush ),
    .bus_rddata        ( bus_rddata ),
    .bus_wrreq         ( bus_wrreq ),
    .bus_wraddr        ( bus_wraddr ),
    .bus_wrlen         ( bus_wrlen ),
    .bus_wrempty       ( bus_wrempty ),
    .bus_wrpop         ( bus_wrpop ),
    .bus_wrdata        ( bus_wrdata )
);

// master_bus_if
master_bus_if #(
    .C_THREAD_ID_WIDTH ( C_THREAD_ID_WIDTH ),
    .C_ADDR_WIDTH      ( C_ADDR_WIDTH ),
    .C_DATA_WIDTH      ( C_DATA_WIDTH ),
    .C_AWUSER_WIDTH    ( C_AWUSER_WIDTH ),
    .C_ARUSER_WIDTH    ( C_ARUSER_WIDTH ),
    .C_WUSER_WIDTH     ( C_WUSER_WIDTH ),
    .C_RUSER_WIDTH     ( C_RUSER_WIDTH ),
    .C_BUSER_WIDTH     ( C_BUSER_WIDTH ),
    .C_USER_VALUE      ( C_USER_VALUE ),
    .C_PROT_VALUE      ( C_PROT_VALUE ),
    .C_CACHE_VALUE     ( C_CACHE_VALUE )
) bi (
    .ACLK              ( ACLK ),
    .ARESETN           ( ARESETN ),
    .AWID              ( AWID ),
    .AWADDR            ( AWADDR ),
    .AWLEN             ( AWLEN ),
    .AWSIZE            ( AWSIZE ),
    .AWBURST           ( AWBURST ),
    .AWLOCK            ( AWLOCK ),
    .AWCACHE           ( AWCACHE ),
    .AWPROT            ( AWPROT ),
    .AWQOS             ( AWQOS ),
    .AWUSER            ( AWUSER ),
    .AWVALID           ( AWVALID ),
    .AWREADY           ( AWREADY ),
    .WDATA             ( WDATA ),
    .WSTRB             ( WSTRB ),
    .WLAST             ( WLAST ),
    .WUSER             ( WUSER ),
    .WVALID            ( WVALID ),
    .WREADY            ( WREADY ),
    .BID               ( BID ),
    .BRESP             ( BRESP ),
    .BUSER             ( BUSER ),
    .BVALID            ( BVALID ),
    .BREADY            ( BREADY ),
    .ARID              ( ARID ),
    .ARADDR            ( ARADDR ),
    .ARLEN             ( ARLEN ),
    .ARSIZE            ( ARSIZE ),
    .ARBURST           ( ARBURST ),
    .ARLOCK            ( ARLOCK ),
    .ARCACHE           ( ARCACHE ),
    .ARPROT            ( ARPROT ),
    .ARQOS             ( ARQOS ),
    .ARUSER            ( ARUSER ),
    .ARVALID           ( ARVALID ),
    .ARREADY           ( ARREADY ),
    .RID               ( RID ),
    .RDATA             ( RDATA ),
    .RRESP             ( RRESP ),
    .RLAST             ( RLAST ),
    .RUSER             ( RUSER ),
    .RVALID            ( RVALID ),
    .RREADY            ( RREADY ),
    .bus_ready         ( bus_ready ),
    .bus_rdreq         ( bus_rdreq ),
    .bus_rdaddr        ( bus_rdaddr ),
    .bus_rdlen         ( bus_rdlen ),
    .bus_rdfull        ( bus_rdfull ),
    .bus_rdpush        ( bus_rdpush ),
    .bus_rddata        ( bus_rddata ),
    .bus_wrreq         ( bus_wrreq ),
    .bus_wraddr        ( bus_wraddr ),
    .bus_wrlen         ( bus_wrlen ),
    .bus_wrempty       ( bus_wrempty ),
    .bus_wrpop         ( bus_wrpop ),
    .bus_wrdata        ( bus_wrdata )
);

endmodule



`timescale 1ns/1ps

module master_bus_if
#(parameter
    C_THREAD_ID_WIDTH = 1,
    C_ADDR_WIDTH      = 32,
    C_DATA_WIDTH      = 32,
    C_AWUSER_WIDTH    = 1,
    C_ARUSER_WIDTH    = 1,
    C_WUSER_WIDTH     = 1,
    C_RUSER_WIDTH     = 1,
    C_BUSER_WIDTH     = 1,
    C_USER_VALUE      = 1'b0,
    C_PROT_VALUE      = 3'b010,
    C_CACHE_VALUE     = 4'b0000
)(
    // system signal
    input  wire                         ACLK,
    input  wire                         ARESETN,
    // write address channel
    output wire [C_THREAD_ID_WIDTH-1:0] AWID,
    output wire [C_ADDR_WIDTH-1:0]      AWADDR,
    output wire [7:0]                   AWLEN,
    output wire [2:0]                   AWSIZE,
    output wire [1:0]                   AWBURST,
    output wire [1:0]                   AWLOCK,
    output wire [3:0]                   AWCACHE,
    output wire [2:0]                   AWPROT,
    output wire [3:0]                   AWQOS,
    output wire [C_AWUSER_WIDTH-1:0]    AWUSER,
    output wire                         AWVALID,
    input  wire                         AWREADY,
    // write data channel
    output wire [C_DATA_WIDTH-1:0]      WDATA,
    output wire [C_DATA_WIDTH/8-1:0]    WSTRB,
    output wire                         WLAST,
    output wire [C_WUSER_WIDTH-1:0]     WUSER,
    output wire                         WVALID,
    input  wire                         WREADY,
    // write response channel
    input  wire [C_THREAD_ID_WIDTH-1:0] BID,
    input  wire [1:0]                   BRESP,
    input  wire [C_BUSER_WIDTH-1:0]     BUSER,
    input  wire                         BVALID,
    output wire                         BREADY,
    // read address channel
    output wire [C_THREAD_ID_WIDTH-1:0] ARID,
    output wire [C_ADDR_WIDTH-1:0]      ARADDR,
    output wire [7:0]                   ARLEN,
    output wire [2:0]                   ARSIZE,
    output wire [1:0]                   ARBURST,
    output wire [1:0]                   ARLOCK,
    output wire [3:0]                   ARCACHE,
    output wire [2:0]                   ARPROT,
    output wire [3:0]                   ARQOS,
    output wire [C_ARUSER_WIDTH-1:0]    ARUSER,
    output wire                         ARVALID,
    input  wire                         ARREADY,
    // read data channel
    input  wire [C_THREAD_ID_WIDTH-1:0] RID,
    input  wire [C_DATA_WIDTH-1:0]      RDATA,
    input  wire [1:0]                   RRESP,
    input  wire                         RLAST,
    input  wire [C_RUSER_WIDTH-1:0]     RUSER,
    input  wire                         RVALID,
    output wire                         RREADY,
    // to user_if
    output wire                         bus_ready,
    input  wire                         bus_rdreq,
    input  wire [C_ADDR_WIDTH-1:0]      bus_rdaddr,
    input  wire [31:0]                  bus_rdlen,
    input  wire                         bus_rdfull,
    output wire                         bus_rdpush,
    output wire [C_DATA_WIDTH-1:0]      bus_rddata,
    input  wire                         bus_wrreq,
    input  wire [C_ADDR_WIDTH-1:0]      bus_wraddr,
    input  wire [31:0]                  bus_wrlen,
    input  wire                         bus_wrempty,
    output wire                         bus_wrpop,
    input  wire [C_DATA_WIDTH-1:0]      bus_wrdata
);
//------------------------Parameter----------------------
localparam
    BUS_ADDR_WIDTH      = C_ADDR_WIDTH,
    BUS_DATA_WIDTH      = C_DATA_WIDTH,
    BUS_DATA_BYTES      = BUS_DATA_WIDTH / 8,
    BUS_ADDR_ALIGN_BITS = log2(BUS_DATA_BYTES);

localparam
    MAX_BEATS = 9'd256,
    BOUNDARY  = 16'h1000 >> BUS_ADDR_ALIGN_BITS;

localparam
    IDLE  = 4'd0,
    WPREP = 4'd1,
    WLOOP = 4'd2,
    WCMD  = 4'd3,
    WDAT  = 4'd4,
    WRSP  = 4'd5,
    RPREP = 4'd6,
    RLOOP = 4'd7,
    RCMD  = 4'd8,
    RDAT  = 4'd9;
//------------------------Local signal-------------------
// fsm
reg  [3:0]                      state;
reg  [3:0]                      next;
// common
reg  [BUS_ADDR_WIDTH-1:0]       addr_buf;
reg  [31:0]                     len_buf;
reg  [31:0]                     total_beats;
reg  [8:0]                      loop_beats;
reg  [BUS_ADDR_WIDTH-1:0]       bus_addr;
reg  [7:0]                      bus_len;
wire                            aw_transfer;
wire                            w_transfer;
wire                            b_transfer;
wire                            ar_transfer;
wire                            r_transfer;
wire [11-BUS_ADDR_ALIGN_BITS:0] start_beat;
wire [8:0]                      tmp_beats0;
wire [8:0]                      tmp_beats1;
// write
reg  [BUS_ADDR_ALIGN_BITS-1:0]  head_bytes;
reg  [BUS_ADDR_ALIGN_BITS-1:0]  tail_bytes;
reg                             first_wbeat;
reg                             last_wbeat;
reg                             bus_wrdata_valid;
wire [BUS_DATA_BYTES-1:0]       wstrb0;
wire [BUS_DATA_BYTES-1:0]       wstrb1;
//------------------------Task and function--------------
function integer log2;
    input integer x;
    integer y;
begin
    y = 0;
    while (x > 1)
    begin
        x = x / 2;
        y = y + 1;
    end
    log2 = y;
end
endfunction
//------------------------Body---------------------------
//++++++++++++++++++++++++fsm++++++++++++++++++++++++++++
// state
always @(posedge ACLK)
begin
    if (!ARESETN)
        state <= IDLE;
    else
        state <= next;
end

// next
always @(*)
begin
    case (state)
        IDLE:
            if (bus_wrreq)
                next = WPREP;
            else if (bus_rdreq)
                next = RPREP;
            else
                next = IDLE;
        WPREP:
            next = WLOOP;
        WLOOP:
            if (total_beats==1'b0)
                next = IDLE;
            else
                next = WCMD;
        WCMD:
            if (aw_transfer)
                next = WDAT;
            else
                next = WCMD;
        WDAT:
            if (w_transfer && loop_beats==1'b1)
                next = WRSP;
            else
                next = WDAT;
        WRSP:
            if (b_transfer)
                next = WLOOP;
            else
                next = WRSP;
        RPREP:
            next = RLOOP;
        RLOOP:
            if (total_beats==1'b0)
                next = IDLE;
            else
                next = RCMD;
        RCMD:
            if (ar_transfer)
                next = RDAT;
            else
                next = RCMD;
        RDAT:
            if (r_transfer && loop_beats==1'b1)
                next = RLOOP;
            else
                next = RDAT;
        default:
            next = IDLE;
    endcase
end
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++common+++++++++++++++++++++++++
assign aw_transfer = AWREADY & AWVALID;
assign w_transfer  = WREADY & WVALID;
assign b_transfer  = BREADY & BVALID;
assign ar_transfer = ARREADY & ARVALID;
assign r_transfer  = RREADY & RVALID;

assign start_beat  = addr_buf[11:BUS_ADDR_ALIGN_BITS];
assign tmp_beats0  = (total_beats < MAX_BEATS)? total_beats : MAX_BEATS;
assign tmp_beats1  = (tmp_beats0 < BOUNDARY - start_beat)? tmp_beats0 : BOUNDARY - start_beat;

// addr_buf
always @(posedge ACLK)
begin
    if (!ARESETN)
        addr_buf <= 1'b0;
    else if (state==IDLE)
    begin
        if (bus_wrreq)
            addr_buf <= bus_wraddr;
        else if (bus_rdreq)
            addr_buf <= bus_rdaddr;
    end
    else if (state==WPREP || state==RPREP)
        addr_buf[BUS_ADDR_ALIGN_BITS-1:0] <= 1'b0;
    else if (state==WLOOP || state==RLOOP)
        addr_buf <= addr_buf + (tmp_beats1 << BUS_ADDR_ALIGN_BITS);
end

// len_buf
always @(posedge ACLK)
begin
    if (!ARESETN)
        len_buf <= 1'b0;
    else if (state==IDLE)
    begin
        if (bus_wrreq)
            len_buf <= bus_wrlen;
        else if (bus_rdreq)
            len_buf <= bus_rdlen;
    end
end

// total_beats
always @(posedge ACLK)
begin
    if (!ARESETN)
        total_beats <= 1'b0;
    else if (state==WPREP || state==RPREP)
        total_beats <= (len_buf + addr_buf[BUS_ADDR_ALIGN_BITS-1:0] +
                {BUS_ADDR_ALIGN_BITS{1'b1}}) >> BUS_ADDR_ALIGN_BITS;
    else if ((state==WCMD && aw_transfer) || (state==RCMD && ar_transfer))
        total_beats <= total_beats - loop_beats;
end

// loop_beats
always @(posedge ACLK)
begin
    if (!ARESETN)
        loop_beats <= 1'b0;
    else if (state==WLOOP || state==RLOOP)
        loop_beats <= tmp_beats1;
    else if (w_transfer | r_transfer)
        loop_beats <= loop_beats - 1'b1;
end

// bus_addr
always @(posedge ACLK)
begin
    if (!ARESETN)
        bus_addr <= 1'b0;
    else if (state==WLOOP || state==RLOOP)
        bus_addr <= addr_buf;
end

// bus_len
always @(posedge ACLK)
begin
    if (!ARESETN)
        bus_len <= 1'b0;
    else if (state==WLOOP || state==RLOOP)
        bus_len <= tmp_beats1 - 1'b1;
end
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++write++++++++++++++++++++++++++
assign wstrb0 = first_wbeat? {BUS_DATA_BYTES{1'b1}} << head_bytes : {BUS_DATA_BYTES{1'b1}};
assign wstrb1 = last_wbeat?  {BUS_DATA_BYTES{1'b1}} >> tail_bytes : {BUS_DATA_BYTES{1'b1}};

// head_bytes
always @(posedge ACLK)
begin
    if (!ARESETN)
        head_bytes <= 1'b0;
    else if (state==WPREP)
        head_bytes <= addr_buf[BUS_ADDR_ALIGN_BITS-1:0];
end

// tail_bytes
always @(posedge ACLK)
begin
    if (!ARESETN)
        tail_bytes <= 1'b0;
    else if (state==WPREP)
        tail_bytes <= (1 << BUS_ADDR_ALIGN_BITS) -
                addr_buf[BUS_ADDR_ALIGN_BITS-1:0] -
                len_buf[BUS_ADDR_ALIGN_BITS-1:0];
end

// first_wbeat
always @(posedge ACLK)
begin
    if (!ARESETN)
        first_wbeat <= 1'b0;
    else if (state==WPREP)
        first_wbeat <= 1'b1;
    else if (w_transfer)
        first_wbeat <= 1'b0;
end

// last_wbeat
always @(posedge ACLK)
begin
    if (!ARESETN)
        last_wbeat <= 1'b0;
    else if (state==WLOOP && total_beats==1'b1)
        last_wbeat <= 1'b1;
    else if (w_transfer)
    begin
        if (total_beats==1'b0 && loop_beats==2'd2)
            last_wbeat <= 1'b1;
        else
            last_wbeat <= 1'b0;
    end
end

// bus_wrdata_valid
always @(posedge ACLK)
begin
    if (!ARESETN)
        bus_wrdata_valid <= 1'b0;
    else if (bus_wrpop)
        bus_wrdata_valid <= 1'b1;
    else if (w_transfer)
        bus_wrdata_valid <= 1'b0;
end
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++bus++++++++++++++++++++++++++++
// write address channel
assign AWID    =   1'b0;
assign AWADDR  =   bus_addr;
assign AWLEN   =   bus_len;
assign AWSIZE  =   BUS_ADDR_ALIGN_BITS[2:0];
assign AWBURST =   2'b01;
assign AWLOCK  =   2'b00;
assign AWCACHE =   C_CACHE_VALUE;
assign AWPROT  =   C_PROT_VALUE;
assign AWQOS   =   4'b0000;
assign AWUSER  =   C_USER_VALUE;
assign AWVALID =   (state==WCMD);
// write data channel
assign WDATA   =   bus_wrdata;
assign WSTRB   =   wstrb0 & wstrb1;
assign WLAST   =   w_transfer & (loop_beats==1'b1);
assign WUSER   =   C_USER_VALUE;
assign WVALID  =   (state==WDAT) & bus_wrdata_valid;
// write response channel
assign BREADY  =   (state==WRSP);
// read address channel
assign ARID    =   1'b0;
assign ARADDR  =   bus_addr;
assign ARLEN   =   bus_len;
assign ARSIZE  =   BUS_ADDR_ALIGN_BITS[2:0];
assign ARBURST =   2'b01;
assign ARLOCK  =   2'b00;
assign ARCACHE =   C_CACHE_VALUE;
assign ARPROT  =   C_PROT_VALUE;
assign ARQOS   =   4'b0000;
assign ARUSER  =   C_USER_VALUE;
assign ARVALID =   (state==RCMD);
// read data channel
assign RREADY  =   (state==RDAT) & ~bus_rdfull;
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++to user_if+++++++++++++++++++++
assign bus_ready  = (state==IDLE);
assign bus_rdpush = r_transfer;
assign bus_rddata = RDATA;
assign bus_wrpop  = ~bus_wrempty & (~bus_wrdata_valid | w_transfer);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

endmodule



`timescale 1ns/1ps

module master_user_if
#(parameter
    C_ADDR_WIDTH      = 32,
    C_DATA_WIDTH      = 32,
    C_USER_DATA_WIDTH = 8,
    C_TARGET_ADDR     = 32'h00000000
)(
    // system signal
    input  wire                         ACLK,
    input  wire                         ARESETN,
    // user ports
    output wire [C_USER_DATA_WIDTH-1:0] USER_datain,
    input  wire [C_USER_DATA_WIDTH-1:0] USER_dataout,
    input  wire [31:0]                  USER_address,
    input  wire [31:0]                  USER_size,
    input  wire                         USER_req_din,
    output wire                         USER_req_full_n,
    input  wire                         USER_req_write,
    output wire                         USER_rsp_empty_n,
    input  wire                         USER_rsp_read,
    // to bus_if
    input  wire                         bus_ready,
    output wire                         bus_rdreq,
    output wire [C_ADDR_WIDTH-1:0]      bus_rdaddr,
    output wire [31:0]                  bus_rdlen,
    output wire                         bus_rdfull,
    input  wire                         bus_rdpush,
    input  wire [C_DATA_WIDTH-1:0]      bus_rddata,
    output wire                         bus_wrreq,
    output wire [C_ADDR_WIDTH-1:0]      bus_wraddr,
    output wire [31:0]                  bus_wrlen,
    output wire                         bus_wrempty,
    input  wire                         bus_wrpop,
    output wire [C_DATA_WIDTH-1:0]      bus_wrdata
);
//------------------------Parameter----------------------
localparam
    INTERNAL_DATA_WIDTH = calc_data_width(C_USER_DATA_WIDTH),
    INTERNAL_DATA_BYTES = INTERNAL_DATA_WIDTH / 8,
    BUS_DATA_WIDTH      = C_DATA_WIDTH,
    BUS_DATA_BYTES      = BUS_DATA_WIDTH / 8,
    SHIFT_BITS          = INTERNAL_DATA_WIDTH < BUS_DATA_WIDTH? INTERNAL_DATA_WIDTH : BUS_DATA_WIDTH,
    SHIFT_BYTES         = SHIFT_BITS / 8,
    BUS_ADDR_ALIGN_BITS = log2(BUS_DATA_BYTES);

localparam
    IDLE  = 4'd0,
    WPREP = 4'd1,
    WPROC = 4'd2,
    WPAD  = 4'd3,
    RPREP = 4'd4,
    RPROC = 4'd5,
    OVER  = 4'd6;

localparam
    FIFO_DEPTH_BITS = 2;
//------------------------Local signal-------------------
// fsm
reg  [3:0]                     state;
reg  [3:0]                     next;
reg  [31:0]                    size_buf;
reg  [31:0]                    addr_buf;
reg  [C_ADDR_WIDTH-1:0]        bus_addr;
reg  [31:0]                    bus_len;
// fifo
wire                           wrfifo_clk;
wire                           wrfifo_aclr;
wire                           wrfifo_empty;
wire                           wrfifo_full;
wire                           wrfifo_rdreq;
wire                           wrfifo_wrreq;
wire [BUS_DATA_WIDTH-1:0]      wrfifo_q;
wire [BUS_DATA_WIDTH-1:0]      wrfifo_data;
wire [FIFO_DEPTH_BITS:0]       wrfifo_usdw;
wire                           rdfifo_clk;
wire                           rdfifo_aclr;
wire                           rdfifo_empty;
wire                           rdfifo_full;
wire                           rdfifo_rdreq;
wire                           rdfifo_wrreq;
wire [BUS_DATA_WIDTH-1:0]      rdfifo_q;
wire [BUS_DATA_WIDTH-1:0]      rdfifo_data;
wire [FIFO_DEPTH_BITS:0]       rdfifo_usdw;
// write
reg  [INTERNAL_DATA_WIDTH-1:0] dataout_buf;
reg  [INTERNAL_DATA_BYTES-1:0] dataout_buf_byte_valid;
reg  [BUS_DATA_WIDTH-1:0]      wrfifo_data_buf;
reg  [BUS_DATA_BYTES-1:0]      wrfifo_data_buf_byte_valid;
reg                            bus_wrreq_buf;
wire                           wr_shift;
wire [31:0]                    wr_addr_tmp;
// read
reg                            rd_first;
reg  [BUS_ADDR_ALIGN_BITS-1:0] rd_head_bytes;
reg                            rdfifo_q_valid;
reg  [BUS_DATA_WIDTH-1:0]      rdfifo_q_buf;
reg  [BUS_DATA_BYTES-1:0]      rdfifo_q_buf_byte_valid;
reg  [INTERNAL_DATA_WIDTH-1:0] datain_buf;
reg  [INTERNAL_DATA_BYTES-1:0] datain_buf_byte_valid;
reg                            bus_rdreq_buf;
wire                           rd_shift;
wire                           rd_save_q;
//------------------------Instantiation------------------
// wrfifo
master_fifo #(
    .DATA_BITS  ( BUS_DATA_WIDTH ),
    .DEPTH_BITS ( FIFO_DEPTH_BITS )
) wrfifo (
    .clk        ( wrfifo_clk ),
    .aclr       ( wrfifo_aclr ),
    .empty      ( wrfifo_empty ),
    .full       ( wrfifo_full ),
    .rdreq      ( wrfifo_rdreq ),
    .wrreq      ( wrfifo_wrreq ),
    .q          ( wrfifo_q ),
    .data       ( wrfifo_data ),
    .usdw       ( wrfifo_usdw )
);

// rdfifo
master_fifo #(
    .DATA_BITS  ( BUS_DATA_WIDTH ),
    .DEPTH_BITS ( FIFO_DEPTH_BITS )
) rdfifo (
    .clk        ( rdfifo_clk ),
    .aclr       ( rdfifo_aclr ),
    .empty      ( rdfifo_empty ),
    .full       ( rdfifo_full ),
    .rdreq      ( rdfifo_rdreq ),
    .wrreq      ( rdfifo_wrreq ),
    .q          ( rdfifo_q ),
    .data       ( rdfifo_data ),
    .usdw       ( rdfifo_usdw )
);
//------------------------Task and function--------------
function integer calc_data_width;
    input integer x;
    integer y;
begin
    y = 1;
    while (y < x) y = y * 2;
    if (y < 8) y = 8;
    calc_data_width = y;
end
endfunction

function integer log2;
    input integer x;
    integer y;
begin
    y = 0;
    while (x > 1)
    begin
        x = x / 2;
        y = y + 1;
    end
    log2 = y;
end
endfunction
//------------------------Body---------------------------
//++++++++++++++++++++++++fsm++++++++++++++++++++++++++++
// state
always @(posedge ACLK)
begin
    if (!ARESETN)
        state <= IDLE;
    else
        state <= next;
end

// next
always @(*)
begin
    case (state)
        IDLE:
            if (USER_req_write)
            begin
                if (USER_req_din)
                    next = WPREP;
                else
                    next = RPREP;
            end
            else
                next = IDLE;
        WPREP:
            next = WPROC;
        WPROC:
            if (size_buf==1'b1 && ~dataout_buf_byte_valid[0])
            begin
                if (wrfifo_data_buf_byte_valid[0])
                    next = OVER;
                else
                    next = WPAD;
            end
            else
                next = WPROC;
        WPAD:
            if (wrfifo_wrreq)
                next = OVER;
            else
                next = WPAD;
        RPREP:
            next = RPROC;
        RPROC:
            if (size_buf==1'b0)
                next = OVER;
            else
                next = RPROC;
        OVER:
            if (bus_ready)
                next = IDLE;
            else
                next = OVER;
        default:
            next = IDLE;
    endcase
end

// size_buf
always @(posedge ACLK)
begin
    if (!ARESETN)
        size_buf <= 1'b0;
    else if (state==IDLE && USER_req_write)
        // USER_size should be 1 at least
        size_buf <= (USER_size == 1'b0)? 1'b1 : USER_size;
    else if ((state==WPREP || state==WPROC) && USER_req_write) // USER_rsp_din = 1
        size_buf <= size_buf - 1'b1;
    else if (state==RPROC && USER_rsp_read)
        size_buf <= size_buf - 1'b1;
end

// addr_buf
always @(posedge ACLK)
begin
    if(!ARESETN)
        addr_buf <= 1'b0;
    else if (state==IDLE && USER_req_write)
        addr_buf <= USER_address;
end

// bus_addr
always @(posedge ACLK)
begin
    if(!ARESETN)
        bus_addr <= 1'b0;
    else if (state==WPREP || state==RPREP)
        bus_addr <= C_TARGET_ADDR + (addr_buf * INTERNAL_DATA_BYTES);
end

// bus_len
always @(posedge ACLK)
begin
    if(!ARESETN)
        bus_len <= 1'b0;
    else if (state==WPREP || state==RPREP)
        bus_len <= size_buf * INTERNAL_DATA_BYTES;
end
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++fifo+++++++++++++++++++++++++++
assign wrfifo_clk   = ACLK;
assign wrfifo_aclr  = ~ARESETN | (state==IDLE);
assign wrfifo_rdreq = bus_wrpop;
assign wrfifo_wrreq = ~wrfifo_full & wrfifo_data_buf_byte_valid[0];
assign wrfifo_data  = wrfifo_data_buf;
assign rdfifo_clk   = ACLK;
assign rdfifo_aclr  = ~ARESETN | (state==IDLE);
assign rdfifo_rdreq = ~rdfifo_empty & (~rdfifo_q_valid | rd_save_q);
assign rdfifo_wrreq = bus_rdpush;
assign rdfifo_data  = bus_rddata;
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++write++++++++++++++++++++++++++
// Write data flow:
// USER_dataout -> dataout_buf -> wrfifo_data_buf -> wrfifo -> bus_wrdata
assign bus_wrreq    = bus_wrreq_buf;
assign bus_wraddr   = bus_addr;
assign bus_wrlen    = bus_len;
assign bus_wrempty  = wrfifo_empty;
assign bus_wrdata   = wrfifo_q;
assign wr_shift     = (~wrfifo_data_buf_byte_valid[0] | wrfifo_wrreq) &
                      dataout_buf_byte_valid[0];
assign wr_addr_tmp  = USER_address * INTERNAL_DATA_BYTES;

// dataout_buf
always @(posedge ACLK)
begin
    if (!ARESETN)
        dataout_buf <= 1'b0;
    else if (USER_req_write & USER_req_din)
        dataout_buf <= USER_dataout;
    else if (wr_shift)
        dataout_buf <= dataout_buf >> SHIFT_BITS;
end

// dataout_buf_byte_valid
always @(posedge ACLK)
begin
    if (!ARESETN)
        dataout_buf_byte_valid <= 1'b0;
    else if (USER_req_write & USER_req_din)
        dataout_buf_byte_valid <= {INTERNAL_DATA_BYTES{1'b1}};
    else if (wr_shift)
        dataout_buf_byte_valid <= dataout_buf_byte_valid >> SHIFT_BYTES;
    else if (state==OVER)
        dataout_buf_byte_valid <= 1'b0;
end

// wrfifo_data_buf
always @(posedge ACLK)
begin
    if (!ARESETN)
        wrfifo_data_buf <= 1'b0;
    else if (wr_shift)
        wrfifo_data_buf <= {dataout_buf[SHIFT_BITS-1:0], wrfifo_data_buf} >> SHIFT_BITS;
    else if (state==WPAD)
        wrfifo_data_buf <= wrfifo_data_buf >> SHIFT_BITS;
    else if (state==OVER)
        wrfifo_data_buf <= 1'b0;
end

// wrfifo_data_buf_byte_valid
always @(posedge ACLK)
begin
    if (!ARESETN)
        wrfifo_data_buf_byte_valid <= 1'b0;
    else if (state==IDLE && next==WPREP)
        wrfifo_data_buf_byte_valid <= ~({BUS_DATA_BYTES{1'b1}} >> wr_addr_tmp[BUS_ADDR_ALIGN_BITS-1:0]);
    else if (wr_shift)
    begin
        if (wrfifo_wrreq)
            wrfifo_data_buf_byte_valid <= {{SHIFT_BYTES{1'b1}}, {BUS_DATA_BYTES{1'b0}}} >> SHIFT_BYTES;
        else
            wrfifo_data_buf_byte_valid <= {{SHIFT_BYTES{1'b1}}, wrfifo_data_buf_byte_valid} >> SHIFT_BYTES;
    end
    else if (wrfifo_wrreq)
        wrfifo_data_buf_byte_valid <= 1'b0;
    else if (state==WPAD)
        wrfifo_data_buf_byte_valid <= {{SHIFT_BYTES{1'b1}}, wrfifo_data_buf_byte_valid} >> SHIFT_BYTES;
    else if (state==OVER)
        wrfifo_data_buf_byte_valid <= 1'b0;
end

// bus_wrreq_buf
always @(posedge ACLK)
begin
    if (!ARESETN)
        bus_wrreq_buf <= 1'b0;
    else if (state==WPREP)
        bus_wrreq_buf <= 1'b1;
    else
        bus_wrreq_buf <= 1'b0;
end
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++read+++++++++++++++++++++++++++
// Read data flow:
// bus_rddata -> rdfifo -> rdfifo_q_buf -> datain_buf -> USER_datain
assign bus_rdreq  = bus_rdreq_buf;
assign bus_rdaddr = bus_addr;
assign bus_rdlen  = bus_len;
assign bus_rdfull = rdfifo_full;
assign rd_shift   = (~datain_buf_byte_valid[0] | USER_rsp_read) &
                    rdfifo_q_buf_byte_valid[0];
assign rd_save_q  = rdfifo_q_valid & (rdfifo_q_buf_byte_valid=={SHIFT_BYTES{rd_shift}});

// rd_first
always @(posedge ACLK)
begin
    if (!ARESETN)
        rd_first <= 1'b1;
    else if (state==IDLE)
        rd_first <= 1'b1;
    else if (rd_save_q)
        rd_first <= 1'b0;
end

// rd_head_bytes
always @(posedge ACLK)
begin
  if (!ARESETN)
        rd_head_bytes <= 1'b0;
    else if (state==IDLE)
        rd_head_bytes <= USER_address * INTERNAL_DATA_BYTES;
end

// rdfifo_q_valid
always @(posedge ACLK)
begin
    if (!ARESETN)
        rdfifo_q_valid <= 1'b0;
    else if (state==IDLE)
        rdfifo_q_valid <= 1'b0;
    else if (rdfifo_rdreq)
        rdfifo_q_valid <= 1'b1;
    else if (rd_save_q)
        rdfifo_q_valid <= 1'b0;
end

// rdfifo_q_buf
always @(posedge ACLK)
begin
    if (!ARESETN)
        rdfifo_q_buf <= 1'b0;
    else if (rd_save_q)
    begin
        if (rd_first)
            rdfifo_q_buf <= rdfifo_q >> (rd_head_bytes * 8);
        else
            rdfifo_q_buf <= rdfifo_q;
    end
    else if (rd_shift)
        rdfifo_q_buf <= rdfifo_q_buf >> SHIFT_BITS;
end

// rdfifo_q_buf_byte_valid
always @(posedge ACLK)
begin
    if (!ARESETN)
        rdfifo_q_buf_byte_valid <= 1'b0;
    else if (rd_save_q)
    begin
        if (rd_first)
            rdfifo_q_buf_byte_valid <= {BUS_DATA_BYTES{1'b1}} >> rd_head_bytes;
        else
            rdfifo_q_buf_byte_valid <= {BUS_DATA_BYTES{1'b1}};
    end
    else if (rd_shift)
        rdfifo_q_buf_byte_valid <= rdfifo_q_buf_byte_valid >> SHIFT_BYTES;
    else if (state==OVER)
        rdfifo_q_buf_byte_valid <= 1'b0;
end

// datain_buf
always @(posedge ACLK)
begin
    if (!ARESETN)
        datain_buf <= 1'b0;
    else if (rd_shift)
        datain_buf <= {rdfifo_q_buf[SHIFT_BITS-1:0], datain_buf} >> SHIFT_BITS;
end

// datain_buf_byte_valid
always @(posedge ACLK)
begin
    if (!ARESETN)
        datain_buf_byte_valid <= 1'b0;
    else if (rd_shift)
    begin
        if (USER_rsp_read)
            datain_buf_byte_valid <= {{SHIFT_BYTES{1'b1}}, {INTERNAL_DATA_BYTES{1'b0}}} >> SHIFT_BYTES;
        else
            datain_buf_byte_valid <= {{SHIFT_BYTES{1'b1}}, datain_buf_byte_valid} >> SHIFT_BYTES;
    end
    else if (USER_rsp_read)
        datain_buf_byte_valid <= 1'b0;
    else if (state==OVER)
        datain_buf_byte_valid <= 1'b0;
end

// bus_rdreq_buf
always @(posedge ACLK)
begin
    if (!ARESETN)
        bus_rdreq_buf <= 1'b0;
    else if (state==RPREP)
        bus_rdreq_buf <= 1'b1;
    else
        bus_rdreq_buf <= 1'b0;
end
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++user ports+++++++++++++++++++++
assign USER_datain      = datain_buf;
assign USER_req_full_n  = (state==IDLE ||state==WPREP || state==WPROC) &
                          (dataout_buf_byte_valid=={SHIFT_BYTES{wr_shift}});
assign USER_rsp_empty_n = (state==RPROC) & datain_buf_byte_valid[0];
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++

endmodule



`timescale 1ns/1ps

module master_fifo
#(parameter
    DATA_BITS  = 8,
    DEPTH_BITS = 4
)(
    input  wire                 clk,
    input  wire                 aclr,
    output wire                 empty,
    output wire                 full,
    input  wire                 rdreq,
    input  wire                 wrreq,
    output wire [DATA_BITS-1:0] q,
    input  wire [DATA_BITS-1:0] data,
    output wire [DEPTH_BITS:0]  usdw
);
//------------------------Parameter----------------------
localparam
    DEPTH = 1 << DEPTH_BITS;
//------------------------Local signal-------------------
reg  [DEPTH_BITS:0]  pread;
reg  [DEPTH_BITS:0]  pwrite;
reg  [DATA_BITS-1:0] q_buf;
reg  [DATA_BITS-1:0] mem[0:DEPTH-1];
//------------------------Body---------------------------
assign q     = q_buf;
assign empty = (pread == pwrite);
assign full  = (pread == (pwrite ^ (1 << DEPTH_BITS)));
assign usdw  = pwrite - pread;

// pwrite
always @(posedge clk or posedge aclr)
begin
    if (aclr)
        pwrite <= 1'b0;
    else if(wrreq)
        pwrite <= pwrite + 1'b1;
end

// pread
always @(posedge clk or posedge aclr)
begin
    if (aclr)
        pread <= 1'b0;
    else if(rdreq)
        pread <= pread + 1'b1;
end

// q_buf
always @(posedge clk or posedge aclr)
begin
    if (aclr)
        q_buf <= 1'b0;
    else if (rdreq)
        q_buf <= mem[pread[DEPTH_BITS-1:0]];
end

// mem
always @(posedge clk)
begin
    if (wrreq)
        mem[pwrite[DEPTH_BITS-1:0]] <= data;
end

endmodule
